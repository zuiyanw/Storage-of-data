#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
int main()
{
	char a = -1;//1的补码是全1
				// 10000000 00000000 00000000 00000001 -1的原码
				// 11111111 11111111 11111111 11111110 -1的反码：符号位不变 其他位按位取反
				// 11111111 11111111 11111111 11111111 补：反码+1
				//							  11111111 -1的二进制存在a中的话 只能存8个bit位 因为char类型只有一个字节 -1在char类型中需要整形提升 因为是负数前面补符号位1
				// 11111111 11111111 11111111 11111111 补码
				// 11111111 11111111 11111111 11111110 补码-1=反码 
				// 10000000 00000000 00000000 00000001 符号位不变其他位按位取反=原码 打印的使用的是这个数的原码
	signed char b = -1;//负数在内存中存储的是这个数的补码，打印的，使用的是这个数的原码
				//							  11111111 b中也是8个1 b为signed 有符号数 跟a的计算方式相同
	unsigned char c = -1;
				//							  11111111 c中也是8个1 c是unsigned 无符号数 最左变的1不代表负数 整形提升的话 前面都补0 就是 00000000 00000000 00000000 11111111 因为是整数 原反补相同 所以为255（二进制转换11111111）
	printf("a=%d, b=%d, c=%d\n", a, b, c);//a，b,c打印的都是int型 需要算出char a，b，c的整形表现形式 所以需要整形提升 
	return 0;                             //整形提升：按照符号位整形提升 负数提升之后的是补码
}